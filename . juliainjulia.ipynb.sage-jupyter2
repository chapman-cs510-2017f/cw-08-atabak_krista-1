{"type":"settings","kernel":"julia","backend_state":"running","trust":true,"kernel_state":"idle"}
{"type":"file","last_load":1508301366248}
{"output":{"0":{"data":{"text/markdown":"juliamap(c,z; maxiter) :   Implement the iteration algorithm for a Julia Set.\n\n**Returns:** integer number of iterations, or zero if the iteration never diverges.\n\n  * c : complex constant definining the set\n  * z : complex number being iterated\n  * maxiter : maximum iteration number, defaults to 100\n"},"exec_count":1}},"exec_count":1,"start":1508301387387,"input":"\"\"\"\njuliamap(c,z; maxiter) :\n  Implement the iteration algorithm for a Julia Set.\n\n**Returns:** integer number of iterations, or zero\nif the iteration never diverges.\n\n - c : complex constant definining the set\n - z : complex number being iterated\n - maxiter : maximum iteration number, defaults to 100\n\"\"\"\nfunction juliamap(c, z; maxiter=100)\n    for n = 1:maxiter\n        z = z^2 + c\n        if abs(z) > 2\n            return n\n        end\n    end\n    return 0\nend\n\n@doc juliamap","state":"done","pos":0,"type":"cell","end":1508301390526,"id":"e5d5c5","kernel":"julia"}
{"output":{"0":{"name":"stdout","text":"33[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 6, 5, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1]"}},"exec_count":6,"start":1508301765785,"input":"# Specialize juliamap to c=0\nj0(z) = juliamap(0,z)\n\n# Evaluate j0 on single complex points. Note: im is the imaginary unit in Julia\nprint( j0( complex(1.1, 0.3) ) )  # Recommended construction for complex numbers\nprint( j0( 1.1 + 0.3im ) )       # Equivalent result, but constructs z in 2 steps\n\n# Evaluate j0 across an array - the . notation automatically vectorizes any function\na = linspace(complex(0.1,0.3), complex(1.5,0.3), 100)\nprint( j0.(a) )","state":"done","pos":1,"type":"cell","end":1508301766389,"id":"a83a48","kernel":"julia"}
{"output":{"0":{"data":{"text/plain":"complex_plane (generic function with 5 methods)"},"exec_count":8}},"exec_count":8,"start":1508301916992,"input":"# Create a complex plane\nfunction complex_plane(xmin=-2, xmax=2, ymin=-2, ymax=2; xpoints=2000, ypoints=2000)\n    # y is a column vector\n    y = linspace(ymin, ymax, ypoints)\n\n    # x uses a transpose, yielding a row vector\n    x = linspace(xmin, xmax, xpoints)'\n\n    # z uses broadcasted addition and multiplication to create a plane\n    z = x .+ y.*im;\n\n    # The final line of a block is treated as the return value, in the absence\n    # of an explicit return statement\nend","state":"done","pos":2,"cell_type":"code","type":"cell","end":1508301917912,"id":"353df6","kernel":"julia"}
{"output":{"0":{"name":"stdout","text":"  0.546800 seconds (156.08 k allocations: 68.817 MiB, 4.29% gc time)\n"},"1":{"name":"stdout","text":"  1.698328 seconds (75.16 k allocations: 34.532 MiB, 11.54% gc time)\n"},"2":{"data":{"text/plain":"2000×2000 Array{Int64,2}:\n 1  1  1  1  1  1  1  1  1  1  1  1  1  …  1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1  …  1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1  …  1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n ⋮              ⋮              ⋮        ⋱        ⋮              ⋮            \n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1  …  1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1  …  1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1"},"exec_count":9}},"exec_count":9,"start":1508301921859,"input":"# The vectorized function can be applied directly to the plane\n@time cplane = complex_plane()\n@time j0p = j0.(cplane)","state":"done","pos":3,"type":"cell","end":1508301927025,"id":"d15cd0","kernel":"julia"}
{"type":"cell","id":"61865a","pos":4,"input":"We creat a complex plane with a column vector and a row vector with default value and then pass this plane to the our juliamap function\n\ncreating a row with the comma and if we want to add another row we use the semicolon."}